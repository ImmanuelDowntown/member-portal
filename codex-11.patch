diff --git a/src/components/DMDock.tsx b/src/components/DMDock.tsx
index a367eb43b4292d7542dc6b9d6f11d33285d97c5b..ea4922a2447270fec32c35668850dcdfcd2af470 100644
--- a/src/components/DMDock.tsx
+++ b/src/components/DMDock.tsx
@@ -169,51 +169,56 @@ export default function DMDock() {
         const unsub = onSnapshot(qref, (snap) => {
           snap.docs.forEach((d) => {
             const data = d.data() as DocumentData;
             const users = (data?.users as string[]) || [];
             const otherUid = users.find((u) => u !== currentUid) || "";
             const t: Thread = {
               id: d.id,
               groupId: g.id,
               users,
               lastText: (data?.lastText as string) || "",
               lastAt: data?.lastAt,
               otherUid,
               otherName: nameCache.current[otherUid],
             };
             all[`${g.id}__${d.id}`] = t;
           });
           const list = Object.values(all).sort((a, b) => {
             const aa = (a.lastAt as any)?.toMillis ? (a.lastAt as any).toMillis() : 0;
             const bb = (b.lastAt as any)?.toMillis ? (b.lastAt as any).toMillis() : 0;
             return bb - aa;
           });
           setThreads(list);
           list.forEach((r) => {
             if (r.otherUid && !r.otherName) {
               resolveName(r.otherUid).then((nm) => {
-                setThreads((prev) => prev.map((p) => (p.id === r.id && p.groupId === r.groupId ? { ...p, otherName: nm } : p)));
+                setThreads((prev) =>
+                  prev.map((p) => (p.id === r.id && p.groupId === r.groupId ? { ...p, otherName: nm } : p))
+                );
+                setActive((prev) =>
+                  prev && prev.id === r.id && prev.groupId === r.groupId ? { ...prev, otherName: nm } : prev
+                );
               });
             }
           });
         }, (err) => {
           if (err && err.code !== "permission-denied") {
             // eslint-disable-next-line no-console
             console.warn("DM per-group listener error:", err);
           }
         });
         perGroupUnsubs.current.push(unsub);
       } catch {}
     });
   }
 
   // Load my groups + aggregate members for compose
   React.useEffect(() => {
     (async () => {
       if (!me) return;
       try {
         // Load my group memberships
         const ms = await getDocs(collection(db, `users/${me}/memberships`));
         const list: MyGroup[] = [];
         for (const d of ms.docs) {
           const gid = d.id;
           list.push({ id: gid });
diff --git a/src/components/DMDock.tsx b/src/components/DMDock.tsx
index a367eb43b4292d7542dc6b9d6f11d33285d97c5b..ea4922a2447270fec32c35668850dcdfcd2af470 100644
--- a/src/components/DMDock.tsx
+++ b/src/components/DMDock.tsx
@@ -263,51 +268,56 @@ export default function DMDock() {
             where("users", "array-contains", me),
             orderBy("lastAt", "desc")
           );
           unsub = onSnapshot(q, async (snap) => {
             const rows: Thread[] = [];
             for (const d of snap.docs) {
               const data = d.data() as DocumentData;
               const parts = d.ref.path.split("/");
               const groupId = parts.length >= 2 ? parts[1] : "";
               const users = (data?.users as string[]) || [];
               const otherUid = users.find((u) => u !== me) || "";
               const t: Thread = {
                 id: d.id,
                 groupId,
                 users,
                 lastText: (data?.lastText as string) || "",
                 lastAt: data?.lastAt,
                 otherUid,
                 otherName: nameCache.current[otherUid],
               };
               rows.push(t);
             }
             for (const r of rows) {
               if (r.otherUid && !r.otherName) {
                 resolveName(r.otherUid).then((nm) => {
-                  setThreads((prev) => prev.map((p) => (p.id === r.id ? { ...p, otherName: nm } : p)));
+                  setThreads((prev) =>
+                    prev.map((p) => (p.id === r.id && p.groupId === r.groupId ? { ...p, otherName: nm } : p))
+                  );
+                  setActive((prev) =>
+                    prev && prev.id === r.id && prev.groupId === r.groupId ? { ...prev, otherName: nm } : prev
+                  );
                 });
               }
             }
             if (!cancelled) setThreads(rows);
             if (rows.length === 0) { await backfillThreadsFromMessages(me); }
           }, (err) => {
             if (err && (err.code === "permission-denied" || err.code === "failed-precondition")) {
               setupPerGroupThreadListeners(me, myGroups);
             } else {
               // eslint-disable-next-line no-console
               console.warn("DM listener error:", err);
             }
           });
         } catch {
           setupPerGroupThreadListeners(me, myGroups);
         }
       } catch {}
     })();
     return () => {
       if (unsub) unsub();
       clearPerGroupUnsubs();
     };
   }, [db, me, meApproved, myGroups]);
 
   // Load messages for active thread
