diff --git a/src/components/DMDock.tsx b/src/components/DMDock.tsx
index a367eb43b4292d7542dc6b9d6f11d33285d97c5b..3d47c8fc34bb7c6e3de1641055aa0b35abd73b97 100644
--- a/src/components/DMDock.tsx
+++ b/src/components/DMDock.tsx
@@ -166,57 +166,50 @@ export default function DMDock() {
     groups.forEach((g) => {
       try {
         const qref = query(collection(db, `groups/${g.id}/directMessages`), where("users", "array-contains", currentUid));
         const unsub = onSnapshot(qref, (snap) => {
           snap.docs.forEach((d) => {
             const data = d.data() as DocumentData;
             const users = (data?.users as string[]) || [];
             const otherUid = users.find((u) => u !== currentUid) || "";
             const t: Thread = {
               id: d.id,
               groupId: g.id,
               users,
               lastText: (data?.lastText as string) || "",
               lastAt: data?.lastAt,
               otherUid,
               otherName: nameCache.current[otherUid],
             };
             all[`${g.id}__${d.id}`] = t;
           });
           const list = Object.values(all).sort((a, b) => {
             const aa = (a.lastAt as any)?.toMillis ? (a.lastAt as any).toMillis() : 0;
             const bb = (b.lastAt as any)?.toMillis ? (b.lastAt as any).toMillis() : 0;
             return bb - aa;
           });
           setThreads(list);
-          list.forEach((r) => {
-            if (r.otherUid && !r.otherName) {
-              resolveName(r.otherUid).then((nm) => {
-                setThreads((prev) => prev.map((p) => (p.id === r.id && p.groupId === r.groupId ? { ...p, otherName: nm } : p)));
-              });
-            }
-          });
         }, (err) => {
           if (err && err.code !== "permission-denied") {
             // eslint-disable-next-line no-console
             console.warn("DM per-group listener error:", err);
           }
         });
         perGroupUnsubs.current.push(unsub);
       } catch {}
     });
   }
 
   // Load my groups + aggregate members for compose
   React.useEffect(() => {
     (async () => {
       if (!me) return;
       try {
         // Load my group memberships
         const ms = await getDocs(collection(db, `users/${me}/memberships`));
         const list: MyGroup[] = [];
         for (const d of ms.docs) {
           const gid = d.id;
           list.push({ id: gid });
         }
         setMyGroups(list);
 
diff --git a/src/components/DMDock.tsx b/src/components/DMDock.tsx
index a367eb43b4292d7542dc6b9d6f11d33285d97c5b..3d47c8fc34bb7c6e3de1641055aa0b35abd73b97 100644
--- a/src/components/DMDock.tsx
+++ b/src/components/DMDock.tsx
@@ -260,78 +253,100 @@ export default function DMDock() {
         try {
           const q = query(
             collectionGroup(db, "directMessages"),
             where("users", "array-contains", me),
             orderBy("lastAt", "desc")
           );
           unsub = onSnapshot(q, async (snap) => {
             const rows: Thread[] = [];
             for (const d of snap.docs) {
               const data = d.data() as DocumentData;
               const parts = d.ref.path.split("/");
               const groupId = parts.length >= 2 ? parts[1] : "";
               const users = (data?.users as string[]) || [];
               const otherUid = users.find((u) => u !== me) || "";
               const t: Thread = {
                 id: d.id,
                 groupId,
                 users,
                 lastText: (data?.lastText as string) || "",
                 lastAt: data?.lastAt,
                 otherUid,
                 otherName: nameCache.current[otherUid],
               };
               rows.push(t);
             }
-            for (const r of rows) {
-              if (r.otherUid && !r.otherName) {
-                resolveName(r.otherUid).then((nm) => {
-                  setThreads((prev) => prev.map((p) => (p.id === r.id ? { ...p, otherName: nm } : p)));
-                });
-              }
-            }
             if (!cancelled) setThreads(rows);
             if (rows.length === 0) { await backfillThreadsFromMessages(me); }
           }, (err) => {
             if (err && (err.code === "permission-denied" || err.code === "failed-precondition")) {
               setupPerGroupThreadListeners(me, myGroups);
             } else {
               // eslint-disable-next-line no-console
               console.warn("DM listener error:", err);
             }
           });
         } catch {
           setupPerGroupThreadListeners(me, myGroups);
         }
       } catch {}
     })();
     return () => {
       if (unsub) unsub();
       clearPerGroupUnsubs();
     };
   }, [db, me, meApproved, myGroups]);
 
+  // Resolve display names for threads and active conversation
+  React.useEffect(() => {
+    threads.forEach((t) => {
+      if (t.otherUid && !t.otherName) {
+        resolveName(t.otherUid).then((nm) => {
+          setThreads((prev) =>
+            prev.map((p) => (p.id === t.id && p.groupId === t.groupId ? { ...p, otherName: nm } : p))
+          );
+          setActive((prev) =>
+            prev && prev.id === t.id && prev.groupId === t.groupId ? { ...prev, otherName: nm } : prev
+          );
+        });
+      }
+    });
+  }, [threads]);
+
+  React.useEffect(() => {
+    if (active && active.otherUid && !active.otherName) {
+      resolveName(active.otherUid).then((nm) => {
+        setActive((prev) =>
+          prev && prev.id === active.id && prev.groupId === active.groupId ? { ...prev, otherName: nm } : prev
+        );
+        setThreads((prev) =>
+          prev.map((p) => (p.id === active.id && p.groupId === active.groupId ? { ...p, otherName: nm } : p))
+        );
+      });
+    }
+  }, [active]);
+
   // Load messages for active thread
   React.useEffect(() => {
     if (!active || !me) {
       if (unsubRef.current) { unsubRef.current(); unsubRef.current = null; }
       setMsgs([]);
       return;
     }
     if (unsubRef.current) { unsubRef.current(); unsubRef.current = null; }
     const colRef = collection(db, `groups/${active.groupId}/directMessages/${active.id}/messages`);
     const q = query(colRef, orderBy("createdAt", "asc"));
     const unsub = onSnapshot(q, (snap) => {
       const rows: ChatMsg[] = snap.docs.map((d) => {
         const data = d.data() as DocumentData;
         return {
           id: d.id,
           text: (data?.text as string) || "",
           from: (data?.from as string) || "",
           to: (data?.to as string) || "",
           displayName: (data?.displayName as string) || "",
           createdAt: data?.createdAt,
         };
       });
       setMsgs(rows);
     });
     unsubRef.current = unsub;
