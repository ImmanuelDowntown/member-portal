diff --git a/src/components/DMDock.tsx b/src/components/DMDock.tsx
index a367eb43b4292d7542dc6b9d6f11d33285d97c5b..3615c737894f14f491856bf859a31f2c77405eef 100644
--- a/src/components/DMDock.tsx
+++ b/src/components/DMDock.tsx
@@ -82,64 +82,73 @@ export default function DMDock() {
       }
     });
     return () => unsub();
   }, [auth, db]);
 
   // UI state
   const [open, setOpen] = React.useState(false);
   const [view, setView] = React.useState<"list" | "chat" | "compose">("list");
 
   const [threads, setThreads] = React.useState<Thread[]>([]);
   const [active, setActive] = React.useState<Thread | null>(null);
   const [msgs, setMsgs] = React.useState<ChatMsg[]>([]);
   const [text, setText] = React.useState("");
   const unsubRef = React.useRef<Unsubscribe | null>(null);
 
   // Compose state (no group picker; we aggregate members across all my groups)
   const [myGroups, setMyGroups] = React.useState<MyGroup[]>([]);
   const [allMembers, setAllMembers] = React.useState<Member[]>([]);
   const [sel, setSel] = React.useState<Record<string, boolean>>({});
   const [composeText, setComposeText] = React.useState("");
   const [composeBusy, setComposeBusy] = React.useState(false);
   const [filter, setFilter] = React.useState("");
 
   // Resolve other user's display name cache
   const nameCache = React.useRef<Record<string, string>>({});
-  async function resolveName(uid: string) {
+  async function resolveName(uid: string, groupId?: string) {
     if (nameCache.current[uid]) return nameCache.current[uid];
     try {
-      let snap = await getDoc(doc(db, "users", uid));
-      let nm = (snap.data()?.displayName as string) || (snap.data()?.name as string);
+      let nm: string | undefined;
+      if (groupId) {
+        try {
+          const mSnap = await getDoc(doc(db, `groups/${groupId}/members`, uid));
+          nm = (mSnap.data()?.displayName as string) || (mSnap.data()?.name as string);
+        } catch {}
+      }
       if (!nm) {
-        snap = await getDoc(doc(db, "admins", uid));
-        nm = (snap.data()?.displayName as string) || (snap.data()?.name as string);
+        try {
+          const uSnap = await getDoc(doc(db, "users", uid));
+          nm = (uSnap.data()?.displayName as string) || (uSnap.data()?.name as string);
+          if (!nm) {
+            const aSnap = await getDoc(doc(db, "admins", uid));
+            nm = (aSnap.data()?.displayName as string) || (aSnap.data()?.name as string);
+          }
+        } catch {}
       }
       const finalName = nm || uid;
       nameCache.current[uid] = finalName;
       return finalName;
-      
-
     } catch {
       return uid;
     }
   }
 
   // Backfill helper: derive missing thread metadata from messages I participated in
   async function backfillThreadsFromMessages(currentUid: string) {
     try {
       const qFrom = query(collectionGroup(db, "messages"), where("from", "==", currentUid));
       const qTo = query(collectionGroup(db, "messages"), where("to", "==", currentUid));
       const [fromSnap, toSnap] = await Promise.all([getDocs(qFrom), getDocs(qTo)]);
       const all = [...fromSnap.docs, ...toSnap.docs];
       const ops: Array<Promise<unknown>> = [];
       for (const d of all) {
         const data = d.data() as DocumentData;
         const parts = d.ref.path.split("/"); // groups/{groupId}/directMessages/{pairId}/messages/{id}
         if (parts.length < 6) continue;
         const groupId = parts[1];
         const pairId = parts[3];
         const otherUid = (data.from === currentUid ? data.to : data.from) as string;
         if (!otherUid) continue;
         const users = [currentUid, otherUid].sort();
         const metaRef = doc(collection(db, `groups/${groupId}/directMessages`), pairId);
         ops.push(setDoc(metaRef, {
           users,
diff --git a/src/components/DMDock.tsx b/src/components/DMDock.tsx
index a367eb43b4292d7542dc6b9d6f11d33285d97c5b..3615c737894f14f491856bf859a31f2c77405eef 100644
--- a/src/components/DMDock.tsx
+++ b/src/components/DMDock.tsx
@@ -166,57 +175,50 @@ export default function DMDock() {
     groups.forEach((g) => {
       try {
         const qref = query(collection(db, `groups/${g.id}/directMessages`), where("users", "array-contains", currentUid));
         const unsub = onSnapshot(qref, (snap) => {
           snap.docs.forEach((d) => {
             const data = d.data() as DocumentData;
             const users = (data?.users as string[]) || [];
             const otherUid = users.find((u) => u !== currentUid) || "";
             const t: Thread = {
               id: d.id,
               groupId: g.id,
               users,
               lastText: (data?.lastText as string) || "",
               lastAt: data?.lastAt,
               otherUid,
               otherName: nameCache.current[otherUid],
             };
             all[`${g.id}__${d.id}`] = t;
           });
           const list = Object.values(all).sort((a, b) => {
             const aa = (a.lastAt as any)?.toMillis ? (a.lastAt as any).toMillis() : 0;
             const bb = (b.lastAt as any)?.toMillis ? (b.lastAt as any).toMillis() : 0;
             return bb - aa;
           });
           setThreads(list);
-          list.forEach((r) => {
-            if (r.otherUid && !r.otherName) {
-              resolveName(r.otherUid).then((nm) => {
-                setThreads((prev) => prev.map((p) => (p.id === r.id && p.groupId === r.groupId ? { ...p, otherName: nm } : p)));
-              });
-            }
-          });
         }, (err) => {
           if (err && err.code !== "permission-denied") {
             // eslint-disable-next-line no-console
             console.warn("DM per-group listener error:", err);
           }
         });
         perGroupUnsubs.current.push(unsub);
       } catch {}
     });
   }
 
   // Load my groups + aggregate members for compose
   React.useEffect(() => {
     (async () => {
       if (!me) return;
       try {
         // Load my group memberships
         const ms = await getDocs(collection(db, `users/${me}/memberships`));
         const list: MyGroup[] = [];
         for (const d of ms.docs) {
           const gid = d.id;
           list.push({ id: gid });
         }
         setMyGroups(list);
 
diff --git a/src/components/DMDock.tsx b/src/components/DMDock.tsx
index a367eb43b4292d7542dc6b9d6f11d33285d97c5b..3615c737894f14f491856bf859a31f2c77405eef 100644
--- a/src/components/DMDock.tsx
+++ b/src/components/DMDock.tsx
@@ -260,78 +262,100 @@ export default function DMDock() {
         try {
           const q = query(
             collectionGroup(db, "directMessages"),
             where("users", "array-contains", me),
             orderBy("lastAt", "desc")
           );
           unsub = onSnapshot(q, async (snap) => {
             const rows: Thread[] = [];
             for (const d of snap.docs) {
               const data = d.data() as DocumentData;
               const parts = d.ref.path.split("/");
               const groupId = parts.length >= 2 ? parts[1] : "";
               const users = (data?.users as string[]) || [];
               const otherUid = users.find((u) => u !== me) || "";
               const t: Thread = {
                 id: d.id,
                 groupId,
                 users,
                 lastText: (data?.lastText as string) || "",
                 lastAt: data?.lastAt,
                 otherUid,
                 otherName: nameCache.current[otherUid],
               };
               rows.push(t);
             }
-            for (const r of rows) {
-              if (r.otherUid && !r.otherName) {
-                resolveName(r.otherUid).then((nm) => {
-                  setThreads((prev) => prev.map((p) => (p.id === r.id ? { ...p, otherName: nm } : p)));
-                });
-              }
-            }
             if (!cancelled) setThreads(rows);
             if (rows.length === 0) { await backfillThreadsFromMessages(me); }
           }, (err) => {
             if (err && (err.code === "permission-denied" || err.code === "failed-precondition")) {
               setupPerGroupThreadListeners(me, myGroups);
             } else {
               // eslint-disable-next-line no-console
               console.warn("DM listener error:", err);
             }
           });
         } catch {
           setupPerGroupThreadListeners(me, myGroups);
         }
       } catch {}
     })();
     return () => {
       if (unsub) unsub();
       clearPerGroupUnsubs();
     };
   }, [db, me, meApproved, myGroups]);
 
+  // Resolve display names for threads and active conversation
+  React.useEffect(() => {
+    threads.forEach((t) => {
+      if (t.otherUid && !t.otherName) {
+        resolveName(t.otherUid, t.groupId).then((nm) => {
+          setThreads((prev) =>
+            prev.map((p) => (p.id === t.id && p.groupId === t.groupId ? { ...p, otherName: nm } : p))
+          );
+          setActive((prev) =>
+            prev && prev.id === t.id && prev.groupId === t.groupId ? { ...prev, otherName: nm } : prev
+          );
+        });
+      }
+    });
+  }, [threads]);
+
+  React.useEffect(() => {
+    if (active && active.otherUid && !active.otherName) {
+      resolveName(active.otherUid, active.groupId).then((nm) => {
+        setActive((prev) =>
+          prev && prev.id === active.id && prev.groupId === active.groupId ? { ...prev, otherName: nm } : prev
+        );
+        setThreads((prev) =>
+          prev.map((p) => (p.id === active.id && p.groupId === active.groupId ? { ...p, otherName: nm } : p))
+        );
+      });
+    }
+  }, [active]);
+
   // Load messages for active thread
   React.useEffect(() => {
     if (!active || !me) {
       if (unsubRef.current) { unsubRef.current(); unsubRef.current = null; }
       setMsgs([]);
       return;
     }
     if (unsubRef.current) { unsubRef.current(); unsubRef.current = null; }
     const colRef = collection(db, `groups/${active.groupId}/directMessages/${active.id}/messages`);
     const q = query(colRef, orderBy("createdAt", "asc"));
     const unsub = onSnapshot(q, (snap) => {
       const rows: ChatMsg[] = snap.docs.map((d) => {
         const data = d.data() as DocumentData;
         return {
           id: d.id,
           text: (data?.text as string) || "",
           from: (data?.from as string) || "",
           to: (data?.to as string) || "",
           displayName: (data?.displayName as string) || "",
           createdAt: data?.createdAt,
         };
       });
       setMsgs(rows);
     });
     unsubRef.current = unsub;
