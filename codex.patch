diff --git a/src/components/DMDock.tsx b/src/components/DMDock.tsx
index a367eb43b4292d7542dc6b9d6f11d33285d97c5b..20f71e270c3e9e019875b30cf82339481b289a7d 100644
--- a/src/components/DMDock.tsx
+++ b/src/components/DMDock.tsx
@@ -82,232 +82,261 @@ export default function DMDock() {
       }
     });
     return () => unsub();
   }, [auth, db]);
 
   // UI state
   const [open, setOpen] = React.useState(false);
   const [view, setView] = React.useState<"list" | "chat" | "compose">("list");
 
   const [threads, setThreads] = React.useState<Thread[]>([]);
   const [active, setActive] = React.useState<Thread | null>(null);
   const [msgs, setMsgs] = React.useState<ChatMsg[]>([]);
   const [text, setText] = React.useState("");
   const unsubRef = React.useRef<Unsubscribe | null>(null);
 
   // Compose state (no group picker; we aggregate members across all my groups)
   const [myGroups, setMyGroups] = React.useState<MyGroup[]>([]);
   const [allMembers, setAllMembers] = React.useState<Member[]>([]);
   const [sel, setSel] = React.useState<Record<string, boolean>>({});
   const [composeText, setComposeText] = React.useState("");
   const [composeBusy, setComposeBusy] = React.useState(false);
   const [filter, setFilter] = React.useState("");
 
   // Resolve other user's display name cache
   const nameCache = React.useRef<Record<string, string>>({});
-  async function resolveName(uid: string) {
+  async function resolveName(uid: string, groupId?: string, pairId?: string) {
     if (nameCache.current[uid]) return nameCache.current[uid];
     try {
-      let snap = await getDoc(doc(db, "users", uid));
-      let nm = (snap.data()?.displayName as string) || (snap.data()?.name as string);
+      let nm: string | undefined;
+      // Try group member doc first (more permissive security rules)
+      if (groupId) {
+        try {
+          const mem = await getDoc(doc(db, `groups/${groupId}/members`, uid));
+          nm = (mem.data()?.displayName as string) || (mem.data()?.name as string);
+        } catch {
+          // ignore
+        }
+      }
       if (!nm) {
-        snap = await getDoc(doc(db, "admins", uid));
+        let snap = await getDoc(doc(db, "users", uid));
         nm = (snap.data()?.displayName as string) || (snap.data()?.name as string);
+        if (!nm) {
+          snap = await getDoc(doc(db, "admins", uid));
+          nm = (snap.data()?.displayName as string) || (snap.data()?.name as string);
+        }
       }
       const finalName = nm || uid;
       nameCache.current[uid] = finalName;
+      // persist to thread meta if possible
+      if (nm && groupId && pairId) {
+        try {
+          const ref = doc(collection(db, `groups/${groupId}/directMessages`), pairId);
+          await setDoc(ref, { [`userNames.${uid}`]: nm }, { merge: true });
+        } catch {}
+      }
       return finalName;
-      
-
     } catch {
       return uid;
     }
   }
 
   // Backfill helper: derive missing thread metadata from messages I participated in
   async function backfillThreadsFromMessages(currentUid: string) {
     try {
       const qFrom = query(collectionGroup(db, "messages"), where("from", "==", currentUid));
       const qTo = query(collectionGroup(db, "messages"), where("to", "==", currentUid));
       const [fromSnap, toSnap] = await Promise.all([getDocs(qFrom), getDocs(qTo)]);
       const all = [...fromSnap.docs, ...toSnap.docs];
       const ops: Array<Promise<unknown>> = [];
       for (const d of all) {
         const data = d.data() as DocumentData;
         const parts = d.ref.path.split("/"); // groups/{groupId}/directMessages/{pairId}/messages/{id}
         if (parts.length < 6) continue;
         const groupId = parts[1];
         const pairId = parts[3];
         const otherUid = (data.from === currentUid ? data.to : data.from) as string;
         if (!otherUid) continue;
         const users = [currentUid, otherUid].sort();
         const metaRef = doc(collection(db, `groups/${groupId}/directMessages`), pairId);
-        ops.push(setDoc(metaRef, {
+        const otherName = await resolveName(otherUid, groupId, pairId);
+        const meta: Record<string, unknown> = {
           users,
           lastText: (data.text as string) || "",
           lastAt: data.createdAt || serverTimestamp(),
           lastSender: (data.from as string) || currentUid,
-        }, { merge: true }));
+        };
+        if (data.displayName) meta[`userNames.${data.from}`] = data.displayName;
+        meta[`userNames.${otherUid}`] = otherName;
+        ops.push(setDoc(metaRef, meta, { merge: true }));
       }
       await Promise.allSettled(ops);
     } catch {
       // ignore
     }
   }
 
   // Fallback: listen per-group if collectionGroup query is blocked by rules
   const perGroupUnsubs = React.useRef<Unsubscribe[]>([]);
   function clearPerGroupUnsubs() {
     perGroupUnsubs.current.forEach((u) => { try { u(); } catch {} });
     perGroupUnsubs.current = [];
   }
   function setupPerGroupThreadListeners(currentUid: string, groups: MyGroup[]) {
     clearPerGroupUnsubs();
     const all: Record<string, Thread> = {};
     groups.forEach((g) => {
       try {
         const qref = query(collection(db, `groups/${g.id}/directMessages`), where("users", "array-contains", currentUid));
         const unsub = onSnapshot(qref, (snap) => {
           snap.docs.forEach((d) => {
             const data = d.data() as DocumentData;
             const users = (data?.users as string[]) || [];
             const otherUid = users.find((u) => u !== currentUid) || "";
             const t: Thread = {
               id: d.id,
               groupId: g.id,
               users,
               lastText: (data?.lastText as string) || "",
               lastAt: data?.lastAt,
               otherUid,
-              otherName: nameCache.current[otherUid],
+              otherName: (data?.userNames?.[otherUid] as string) || nameCache.current[otherUid],
             };
             all[`${g.id}__${d.id}`] = t;
           });
           const list = Object.values(all).sort((a, b) => {
             const aa = (a.lastAt as any)?.toMillis ? (a.lastAt as any).toMillis() : 0;
             const bb = (b.lastAt as any)?.toMillis ? (b.lastAt as any).toMillis() : 0;
             return bb - aa;
           });
           setThreads(list);
           list.forEach((r) => {
             if (r.otherUid && !r.otherName) {
-              resolveName(r.otherUid).then((nm) => {
-                setThreads((prev) => prev.map((p) => (p.id === r.id && p.groupId === r.groupId ? { ...p, otherName: nm } : p)));
+              resolveName(r.otherUid, r.groupId, r.id).then((nm) => {
+                setThreads((prev) =>
+                  prev.map((p) => (p.id === r.id && p.groupId === r.groupId ? { ...p, otherName: nm } : p))
+                );
               });
             }
           });
         }, (err) => {
           if (err && err.code !== "permission-denied") {
             // eslint-disable-next-line no-console
             console.warn("DM per-group listener error:", err);
           }
         });
         perGroupUnsubs.current.push(unsub);
       } catch {}
     });
   }
 
   // Load my groups + aggregate members for compose
   React.useEffect(() => {
     (async () => {
       if (!me) return;
       try {
         // Load my group memberships
         const ms = await getDocs(collection(db, `users/${me}/memberships`));
         const list: MyGroup[] = [];
         for (const d of ms.docs) {
           const gid = d.id;
           list.push({ id: gid });
         }
         setMyGroups(list);
 
         // Load members of each group and aggregate/dedupe (excluding me)
         const seen: Record<string, boolean> = {};
         const members: Member[] = [];
         for (const g of list) {
           try {
             const mSnap = await getDocs(collection(db, `groups/${g.id}/members`));
             for (const m of mSnap.docs) {
               if (m.id === me || seen[m.id]) continue;
               seen[m.id] = true;
-              // optional profile enrich
-              let displayName: string | undefined;
-              let email: string | undefined;
-              try {
-                const u = await getDoc(doc(db, "users", m.id));
-                const data = u.data() as DocumentData | undefined;
-                displayName = (data?.displayName as string) || undefined;
-                email = (data?.email as string) || undefined;
-              } catch {}
+              // pull from member doc first
+              const mdata = m.data() as DocumentData;
+              let displayName = (mdata?.displayName as string) || (mdata?.name as string) || undefined;
+              let email = (mdata?.email as string) || undefined;
+              // optional profile enrich if missing
+              if (!displayName || !email) {
+                try {
+                  const u = await getDoc(doc(db, "users", m.id));
+                  const data = u.data() as DocumentData | undefined;
+                  displayName = displayName || (data?.displayName as string) || (data?.name as string) || undefined;
+                  email = email || (data?.email as string) || undefined;
+                } catch {}
+              }
               members.push({ uid: m.id, displayName, email });
             }
           } catch {}
         }
         setAllMembers(members);
       } catch {
         setMyGroups([]);
         setAllMembers([]);
       }
     })();
   }, [db, me]);
 
   // Listen for my DM threads across all groups (requires approval)
   React.useEffect(() => {
     if (!me || !meApproved) return;
     let unsub: Unsubscribe | null = null;
     let cancelled = false;
     (async () => {
       try {
         try {
           const q = query(
             collectionGroup(db, "directMessages"),
             where("users", "array-contains", me),
             orderBy("lastAt", "desc")
           );
           unsub = onSnapshot(q, async (snap) => {
             const rows: Thread[] = [];
             for (const d of snap.docs) {
-              const data = d.data() as DocumentData;
-              const parts = d.ref.path.split("/");
-              const groupId = parts.length >= 2 ? parts[1] : "";
-              const users = (data?.users as string[]) || [];
-              const otherUid = users.find((u) => u !== me) || "";
-              const t: Thread = {
-                id: d.id,
-                groupId,
-                users,
-                lastText: (data?.lastText as string) || "",
-                lastAt: data?.lastAt,
-                otherUid,
-                otherName: nameCache.current[otherUid],
-              };
+            const data = d.data() as DocumentData;
+            const parts = d.ref.path.split("/");
+            const groupId = parts.length >= 2 ? parts[1] : "";
+            const users = (data?.users as string[]) || [];
+            const otherUid = users.find((u) => u !== me) || "";
+            const t: Thread = {
+              id: d.id,
+              groupId,
+              users,
+              lastText: (data?.lastText as string) || "",
+              lastAt: data?.lastAt,
+              otherUid,
+              otherName: (data?.userNames?.[otherUid] as string) || nameCache.current[otherUid],
+            };
               rows.push(t);
             }
             for (const r of rows) {
               if (r.otherUid && !r.otherName) {
-                resolveName(r.otherUid).then((nm) => {
-                  setThreads((prev) => prev.map((p) => (p.id === r.id ? { ...p, otherName: nm } : p)));
+                resolveName(r.otherUid, r.groupId, r.id).then((nm) => {
+                  setThreads((prev) =>
+                    prev.map((p) => (p.id === r.id && p.groupId === r.groupId ? { ...p, otherName: nm } : p))
+                  );
                 });
               }
             }
             if (!cancelled) setThreads(rows);
             if (rows.length === 0) { await backfillThreadsFromMessages(me); }
           }, (err) => {
             if (err && (err.code === "permission-denied" || err.code === "failed-precondition")) {
               setupPerGroupThreadListeners(me, myGroups);
             } else {
               // eslint-disable-next-line no-console
               console.warn("DM listener error:", err);
             }
           });
         } catch {
           setupPerGroupThreadListeners(me, myGroups);
         }
       } catch {}
     })();
     return () => {
       if (unsub) unsub();
       clearPerGroupUnsubs();
     };
   }, [db, me, meApproved, myGroups]);
 
   // Load messages for active thread
diff --git a/src/components/DMDock.tsx b/src/components/DMDock.tsx
index a367eb43b4292d7542dc6b9d6f11d33285d97c5b..20f71e270c3e9e019875b30cf82339481b289a7d 100644
--- a/src/components/DMDock.tsx
+++ b/src/components/DMDock.tsx
@@ -342,92 +371,105 @@ export default function DMDock() {
   async function ensureThreadFor(targetUid: string): Promise<{ groupId: string; pid: string }> {
     if (!me) throw new Error("No user");
     // Prefer an existing thread
     const existing = threads.find((t) => t.otherUid === targetUid);
     if (existing) return { groupId: existing.groupId, pid: existing.id };
     // Find first shared group where target is a member
     for (const g of myGroups) {
       try {
         const m = await getDoc(doc(db, `groups/${g.id}/members`, targetUid));
         if (m.exists()) return { groupId: g.id, pid: pairIdFor(me, targetUid) };
       } catch {}
     }
     // Fallback to my first group (keeps schema consistent)
     const fallback = myGroups[0]?.id;
     if (!fallback) throw new Error("No group memberships found");
     return { groupId: fallback, pid: pairIdFor(me, targetUid) };
   }
 
   async function send() {
     if (!active || !me) return;
     const txt = text.trim();
     if (!txt) return;
     const toUid = active.otherUid;
     try {
       const col = collection(db, `groups/${active.groupId}/directMessages/${active.id}/messages`);
+      const myName = (auth.currentUser?.displayName as string) || "Member";
+      const otherName =
+        allMembers.find((m) => m.uid === toUid)?.displayName || (await resolveName(toUid, active.groupId));
       await addDoc(col, {
         text: txt,
         from: me,
         to: toUid,
-        displayName: (auth.currentUser?.displayName as string) || "Member",
+        displayName: myName,
         createdAt: serverTimestamp(),
       });
-      // upsert thread meta
-      await setDoc(
-        doc(collection(db, `groups/${active.groupId}/directMessages`), active.id),
-        { users: [me, toUid].sort(), lastText: txt, lastAt: serverTimestamp(), lastSender: me },
-        { merge: true }
-      );
+      // upsert thread meta with both participants' display names
+      const meta: Record<string, unknown> = {
+        users: [me, toUid].sort(),
+        lastText: txt,
+        lastAt: serverTimestamp(),
+        lastSender: me,
+      };
+      meta[`userNames.${me}`] = myName;
+      meta[`userNames.${toUid}`] = otherName;
+      await setDoc(doc(collection(db, `groups/${active.groupId}/directMessages`), active.id), meta, { merge: true });
       setText("");
     } catch {
       // eslint-disable-next-line no-alert
       alert("Could not send message.");
     }
   }
 
   async function sendCompose() {
     if (!me) return;
     const targets = Object.entries(sel).filter(([,v]) => v).map(([k]) => k);
     const body = composeText.trim();
     if (targets.length === 0 || !body) return;
     setComposeBusy(true);
     try {
       for (const toUid of targets) {
         const { groupId, pid } = await ensureThreadFor(toUid);
+        const myName = (auth.currentUser?.displayName as string) || "Member";
+        const otherName =
+          allMembers.find((m) => m.uid === toUid)?.displayName || (await resolveName(toUid, groupId));
         await addDoc(collection(db, `groups/${groupId}/directMessages/${pid}/messages`), {
           text: body,
           from: me,
           to: toUid,
-          displayName: (auth.currentUser?.displayName as string) || "Member",
+          displayName: myName,
           createdAt: serverTimestamp(),
         });
-        await setDoc(doc(db, `groups/${groupId}/directMessages/${pid}`), {
+        const meta: Record<string, unknown> = {
           users: [me, toUid].sort(),
           lastText: body,
           lastAt: serverTimestamp(),
           lastSender: me,
-        }, { merge: true });
+        };
+        meta[`userNames.${me}`] = myName;
+        meta[`userNames.${toUid}`] = otherName;
+        await setDoc(doc(db, `groups/${groupId}/directMessages/${pid}`), meta, { merge: true });
       }
       setComposeText("");
       setSel({});
       setView("list");
     } catch {
       // eslint-disable-next-line no-alert
       alert("Failed to send message(s).");
     } finally {
       setComposeBusy(false);
     }
   }
 
   async function deleteMessage(msgId: string) {
     if (!active || !me) return;
     // Allow delete if I am the sender OR I am super admin
     const msg = msgs.find((m) => m.id === msgId);
     if (!msg) return;
     if (!(msg.from === me || isSuper)) return;
     try {
       await deleteDoc(doc(db, `groups/${active.groupId}/directMessages/${active.id}/messages/${msgId}`));
     } catch {
       // eslint-disable-next-line no-alert
       alert("Failed to delete message (check rules).");
     }
   }
