diff --git a/src/components/DMDock.tsx b/src/components/DMDock.tsx
index a367eb43b4292d7542dc6b9d6f11d33285d97c5b..9578fa5334a667f517212169ae3636b99b603221 100644
--- a/src/components/DMDock.tsx
+++ b/src/components/DMDock.tsx
@@ -311,50 +311,57 @@ export default function DMDock() {
   }, [db, me, meApproved, myGroups]);
 
   // Load messages for active thread
   React.useEffect(() => {
     if (!active || !me) {
       if (unsubRef.current) { unsubRef.current(); unsubRef.current = null; }
       setMsgs([]);
       return;
     }
     if (unsubRef.current) { unsubRef.current(); unsubRef.current = null; }
     const colRef = collection(db, `groups/${active.groupId}/directMessages/${active.id}/messages`);
     const q = query(colRef, orderBy("createdAt", "asc"));
     const unsub = onSnapshot(q, (snap) => {
       const rows: ChatMsg[] = snap.docs.map((d) => {
         const data = d.data() as DocumentData;
         return {
           id: d.id,
           text: (data?.text as string) || "",
           from: (data?.from as string) || "",
           to: (data?.to as string) || "",
           displayName: (data?.displayName as string) || "",
           createdAt: data?.createdAt,
         };
       });
       setMsgs(rows);
+      rows.forEach((r) => {
+        if (!r.displayName) {
+          resolveName(r.from).then((nm) => {
+            setMsgs((prev) => prev.map((m) => (m.id === r.id ? { ...m, displayName: nm } : m)));
+          });
+        }
+      });
     });
     unsubRef.current = unsub;
     return () => { if (unsubRef.current) { unsubRef.current(); unsubRef.current = null; } };
   }, [db, active?.groupId, active?.id, me]);
 
   // Ensure thread group for a target uid (existing thread, or first group we both share)
   async function ensureThreadFor(targetUid: string): Promise<{ groupId: string; pid: string }> {
     if (!me) throw new Error("No user");
     // Prefer an existing thread
     const existing = threads.find((t) => t.otherUid === targetUid);
     if (existing) return { groupId: existing.groupId, pid: existing.id };
     // Find first shared group where target is a member
     for (const g of myGroups) {
       try {
         const m = await getDoc(doc(db, `groups/${g.id}/members`, targetUid));
         if (m.exists()) return { groupId: g.id, pid: pairIdFor(me, targetUid) };
       } catch {}
     }
     // Fallback to my first group (keeps schema consistent)
     const fallback = myGroups[0]?.id;
     if (!fallback) throw new Error("No group memberships found");
     return { groupId: fallback, pid: pairIdFor(me, targetUid) };
   }
 
   async function send() {
diff --git a/src/components/DMDock.tsx b/src/components/DMDock.tsx
index a367eb43b4292d7542dc6b9d6f11d33285d97c5b..9578fa5334a667f517212169ae3636b99b603221 100644
--- a/src/components/DMDock.tsx
+++ b/src/components/DMDock.tsx
@@ -531,52 +538,56 @@ export default function DMDock() {
                 </ul>
               )}
             </div>
           )}
 
           {/* Right: Panel */}
           <div className="flex-1 h-full flex flex-col">
             {view === "chat" && active && (
               <>
                 <div className="px-3 py-2 border-b border-slate-800 flex items-center gap-2">
                   <button
                     type="button"
                     onClick={() => setView("list")}
                     className="text-xs rounded-md border border-slate-700 px-2 py-1 hover:bg-slate-800 md:hidden"
                   >
                     ← Back
                   </button>
                   <div className="text-sm font-semibold truncate">{active.otherName || active.otherUid}</div>
                   <div className="text-xs text-slate-400 ml-auto hidden md:block">Group: {active.groupId}</div>
                 </div>
 
                 <div className="flex-1 overflow-auto p-3 space-y-2">
                   {msgs.map((m) => {
                     const mine = m.from === me;
                     return (
-                      <div key={m.id} className={`max-w-[85%] md:max-w-[80%] rounded-lg px-3 py-2 text-sm relative ${mine ? "ml-auto border border-slate-700" : "bg-slate-800"}`}>
-                        {m.text}
+                      <div
+                        key={m.id}
+                        className={`max-w-[85%] md:max-w-[80%] rounded-lg px-3 py-2 text-sm relative ${mine ? "ml-auto border border-slate-700" : "bg-slate-800"}`}
+                      >
+                        <div className="text-xs opacity-70 mb-0.5">{m.displayName || m.from}</div>
+                        <div>{m.text}</div>
                         {(mine || isSuper) && (
                           <button
                             type="button"
                             onClick={() => void deleteMessage(m.id)}
                             className="absolute -top-2 -right-2 text-[10px] rounded-full border border-slate-700 bg-slate-900 px-1.5 py-0.5 hover:bg-slate-800"
                             title="Delete message"
                           >
                             ×
                           </button>
                         )}
                       </div>
                     );
                   })}
                   {msgs.length === 0 && <div className="text-sm text-slate-300">No messages in this conversation yet.</div>}
                 </div>
 
                 <div className="border-t border-slate-800 p-2 flex gap-2">
                   <textarea
                     value={text}
                     onChange={(e) => setText(e.target.value)}
                     placeholder="Write a message…"
                     className="flex-1 rounded-lg border border-slate-700 bg-slate-800 px-3 py-2 text-sm outline-none text-white placeholder:text-slate-400 h-10 md:h-auto md:min-h-[40px] max-h-28"
                     onKeyDown={(e) => { if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); void send(); } }}
                   />
                   <button
