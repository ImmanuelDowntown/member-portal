diff --git a/src/components/DMDock.tsx b/src/components/DMDock.tsx
index a367eb43b4292d7542dc6b9d6f11d33285d97c5b..9e54abd2519679c2a83b5a43ed9049da03b55c46 100644
--- a/src/components/DMDock.tsx
+++ b/src/components/DMDock.tsx
@@ -82,64 +82,74 @@ export default function DMDock() {
       }
     });
     return () => unsub();
   }, [auth, db]);
 
   // UI state
   const [open, setOpen] = React.useState(false);
   const [view, setView] = React.useState<"list" | "chat" | "compose">("list");
 
   const [threads, setThreads] = React.useState<Thread[]>([]);
   const [active, setActive] = React.useState<Thread | null>(null);
   const [msgs, setMsgs] = React.useState<ChatMsg[]>([]);
   const [text, setText] = React.useState("");
   const unsubRef = React.useRef<Unsubscribe | null>(null);
 
   // Compose state (no group picker; we aggregate members across all my groups)
   const [myGroups, setMyGroups] = React.useState<MyGroup[]>([]);
   const [allMembers, setAllMembers] = React.useState<Member[]>([]);
   const [sel, setSel] = React.useState<Record<string, boolean>>({});
   const [composeText, setComposeText] = React.useState("");
   const [composeBusy, setComposeBusy] = React.useState(false);
   const [filter, setFilter] = React.useState("");
 
   // Resolve other user's display name cache
   const nameCache = React.useRef<Record<string, string>>({});
-  async function resolveName(uid: string) {
+  async function resolveName(uid: string, groupId?: string) {
     if (nameCache.current[uid]) return nameCache.current[uid];
     try {
-      let snap = await getDoc(doc(db, "users", uid));
-      let nm = (snap.data()?.displayName as string) || (snap.data()?.name as string);
+      let nm: string | undefined;
+      // Try group member doc first (more permissive security rules)
+      if (groupId) {
+        try {
+          const mem = await getDoc(doc(db, `groups/${groupId}/members`, uid));
+          nm = (mem.data()?.displayName as string) || (mem.data()?.name as string);
+        } catch {
+          // ignore
+        }
+      }
       if (!nm) {
-        snap = await getDoc(doc(db, "admins", uid));
+        let snap = await getDoc(doc(db, "users", uid));
         nm = (snap.data()?.displayName as string) || (snap.data()?.name as string);
+        if (!nm) {
+          snap = await getDoc(doc(db, "admins", uid));
+          nm = (snap.data()?.displayName as string) || (snap.data()?.name as string);
+        }
       }
       const finalName = nm || uid;
       nameCache.current[uid] = finalName;
       return finalName;
-      
-
     } catch {
       return uid;
     }
   }
 
   // Backfill helper: derive missing thread metadata from messages I participated in
   async function backfillThreadsFromMessages(currentUid: string) {
     try {
       const qFrom = query(collectionGroup(db, "messages"), where("from", "==", currentUid));
       const qTo = query(collectionGroup(db, "messages"), where("to", "==", currentUid));
       const [fromSnap, toSnap] = await Promise.all([getDocs(qFrom), getDocs(qTo)]);
       const all = [...fromSnap.docs, ...toSnap.docs];
       const ops: Array<Promise<unknown>> = [];
       for (const d of all) {
         const data = d.data() as DocumentData;
         const parts = d.ref.path.split("/"); // groups/{groupId}/directMessages/{pairId}/messages/{id}
         if (parts.length < 6) continue;
         const groupId = parts[1];
         const pairId = parts[3];
         const otherUid = (data.from === currentUid ? data.to : data.from) as string;
         if (!otherUid) continue;
         const users = [currentUid, otherUid].sort();
         const metaRef = doc(collection(db, `groups/${groupId}/directMessages`), pairId);
         ops.push(setDoc(metaRef, {
           users,
diff --git a/src/components/DMDock.tsx b/src/components/DMDock.tsx
index a367eb43b4292d7542dc6b9d6f11d33285d97c5b..9e54abd2519679c2a83b5a43ed9049da03b55c46 100644
--- a/src/components/DMDock.tsx
+++ b/src/components/DMDock.tsx
@@ -168,146 +178,154 @@ export default function DMDock() {
         const qref = query(collection(db, `groups/${g.id}/directMessages`), where("users", "array-contains", currentUid));
         const unsub = onSnapshot(qref, (snap) => {
           snap.docs.forEach((d) => {
             const data = d.data() as DocumentData;
             const users = (data?.users as string[]) || [];
             const otherUid = users.find((u) => u !== currentUid) || "";
             const t: Thread = {
               id: d.id,
               groupId: g.id,
               users,
               lastText: (data?.lastText as string) || "",
               lastAt: data?.lastAt,
               otherUid,
               otherName: nameCache.current[otherUid],
             };
             all[`${g.id}__${d.id}`] = t;
           });
           const list = Object.values(all).sort((a, b) => {
             const aa = (a.lastAt as any)?.toMillis ? (a.lastAt as any).toMillis() : 0;
             const bb = (b.lastAt as any)?.toMillis ? (b.lastAt as any).toMillis() : 0;
             return bb - aa;
           });
           setThreads(list);
           list.forEach((r) => {
             if (r.otherUid && !r.otherName) {
-              resolveName(r.otherUid).then((nm) => {
-                setThreads((prev) => prev.map((p) => (p.id === r.id && p.groupId === r.groupId ? { ...p, otherName: nm } : p)));
+              resolveName(r.otherUid, r.groupId).then((nm) => {
+                setThreads((prev) =>
+                  prev.map((p) => (p.id === r.id && p.groupId === r.groupId ? { ...p, otherName: nm } : p))
+                );
               });
             }
           });
         }, (err) => {
           if (err && err.code !== "permission-denied") {
             // eslint-disable-next-line no-console
             console.warn("DM per-group listener error:", err);
           }
         });
         perGroupUnsubs.current.push(unsub);
       } catch {}
     });
   }
 
   // Load my groups + aggregate members for compose
   React.useEffect(() => {
     (async () => {
       if (!me) return;
       try {
         // Load my group memberships
         const ms = await getDocs(collection(db, `users/${me}/memberships`));
         const list: MyGroup[] = [];
         for (const d of ms.docs) {
           const gid = d.id;
           list.push({ id: gid });
         }
         setMyGroups(list);
 
         // Load members of each group and aggregate/dedupe (excluding me)
         const seen: Record<string, boolean> = {};
         const members: Member[] = [];
         for (const g of list) {
           try {
             const mSnap = await getDocs(collection(db, `groups/${g.id}/members`));
             for (const m of mSnap.docs) {
               if (m.id === me || seen[m.id]) continue;
               seen[m.id] = true;
-              // optional profile enrich
-              let displayName: string | undefined;
-              let email: string | undefined;
-              try {
-                const u = await getDoc(doc(db, "users", m.id));
-                const data = u.data() as DocumentData | undefined;
-                displayName = (data?.displayName as string) || undefined;
-                email = (data?.email as string) || undefined;
-              } catch {}
+              // pull from member doc first
+              const mdata = m.data() as DocumentData;
+              let displayName = (mdata?.displayName as string) || (mdata?.name as string) || undefined;
+              let email = (mdata?.email as string) || undefined;
+              // optional profile enrich if missing
+              if (!displayName || !email) {
+                try {
+                  const u = await getDoc(doc(db, "users", m.id));
+                  const data = u.data() as DocumentData | undefined;
+                  displayName = displayName || (data?.displayName as string) || (data?.name as string) || undefined;
+                  email = email || (data?.email as string) || undefined;
+                } catch {}
+              }
               members.push({ uid: m.id, displayName, email });
             }
           } catch {}
         }
         setAllMembers(members);
       } catch {
         setMyGroups([]);
         setAllMembers([]);
       }
     })();
   }, [db, me]);
 
   // Listen for my DM threads across all groups (requires approval)
   React.useEffect(() => {
     if (!me || !meApproved) return;
     let unsub: Unsubscribe | null = null;
     let cancelled = false;
     (async () => {
       try {
         try {
           const q = query(
             collectionGroup(db, "directMessages"),
             where("users", "array-contains", me),
             orderBy("lastAt", "desc")
           );
           unsub = onSnapshot(q, async (snap) => {
             const rows: Thread[] = [];
             for (const d of snap.docs) {
               const data = d.data() as DocumentData;
               const parts = d.ref.path.split("/");
               const groupId = parts.length >= 2 ? parts[1] : "";
               const users = (data?.users as string[]) || [];
               const otherUid = users.find((u) => u !== me) || "";
               const t: Thread = {
                 id: d.id,
                 groupId,
                 users,
                 lastText: (data?.lastText as string) || "",
                 lastAt: data?.lastAt,
                 otherUid,
                 otherName: nameCache.current[otherUid],
               };
               rows.push(t);
             }
             for (const r of rows) {
               if (r.otherUid && !r.otherName) {
-                resolveName(r.otherUid).then((nm) => {
-                  setThreads((prev) => prev.map((p) => (p.id === r.id ? { ...p, otherName: nm } : p)));
+                resolveName(r.otherUid, r.groupId).then((nm) => {
+                  setThreads((prev) =>
+                    prev.map((p) => (p.id === r.id && p.groupId === r.groupId ? { ...p, otherName: nm } : p))
+                  );
                 });
               }
             }
             if (!cancelled) setThreads(rows);
             if (rows.length === 0) { await backfillThreadsFromMessages(me); }
           }, (err) => {
             if (err && (err.code === "permission-denied" || err.code === "failed-precondition")) {
               setupPerGroupThreadListeners(me, myGroups);
             } else {
               // eslint-disable-next-line no-console
               console.warn("DM listener error:", err);
             }
           });
         } catch {
           setupPerGroupThreadListeners(me, myGroups);
         }
       } catch {}
     })();
     return () => {
       if (unsub) unsub();
       clearPerGroupUnsubs();
     };
   }, [db, me, meApproved, myGroups]);
 
   // Load messages for active thread
